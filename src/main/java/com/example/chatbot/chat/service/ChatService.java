package com.example.chatbot.chat.service;import com.example.chatbot.chat.dto.*;import com.example.chatbot.chat.entity.Conversation;import com.example.chatbot.chat.repository.ConversationRepository;import com.example.chatbot.common.exception.ConversationAccessDeniedException;import com.example.chatbot.common.exception.ConversationNotFoundException;import com.example.chatbot.message.dto.MessageResponse;import com.example.chatbot.message.entity.Message;import com.example.chatbot.message.repository.MessageRepository;import com.example.chatbot.message.service.MessageService;import com.example.chatbot.openAI.dto.AiMessage;import com.example.chatbot.openAI.service.OpenAiService;import com.example.chatbot.user.entity.User;import com.example.chatbot.user.repository.UserRepository;import java.util.Collections;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;import java.util.ArrayList;import java.util.List;import java.util.stream.Collectors;/** * 채팅 비즈니스 로직 서비스 * * @author : 오승훈 * @fileName : ChatService * @since : 2026-02-05 */@Slf4j@Service@RequiredArgsConstructor@Transactional(readOnly = true)public class ChatService {  private final OpenAiService openAiService;  private final ConversationRepository conversationRepository;  private final MessageService messageService;  private final MessageRepository messageRepository;  private final UserRepository userRepository;  /**   * 새로운 대화 시작 & 채팅   */  @Transactional  public ChatResponse chat(String userMessage,Long conversationId, Long userId) {    log.info("채팅 요청 - 사용자 ID: {}, 대화 ID: {}, 사용자 메시지: {}",userId, conversationId, userMessage);    Conversation conversation;    List<AiMessage> aiMessages = new ArrayList<>();    if(conversationId == null) {      // 1. 새 대화 생성 (제목은 사용자 메시지의 앞 30자)      User user = userRepository.findById(userId)          .orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다."));      String title = userMessage.length() > 30          ? userMessage.substring(0, 30) + "..."          : userMessage;      conversation = Conversation.builder()          .title(title)          .user(user)          .build();      conversationRepository.save(conversation);    }    else{      //기존 대화 이어가기      conversation = conversationRepository          .findByConversationIdAndUserUserId(conversationId, userId)          .orElseThrow(() -> new ConversationAccessDeniedException(conversationId));      //최근 10개 메시지 조회      List<Message> recentMessages = messageRepository          .findTop10ByConversationConversationIdOrderByCreatedAtDesc(conversationId);      // 역순 정렬(오래된 것부터)      Collections.reverse(recentMessages);      // OpenAI 형식으로 변환      aiMessages = recentMessages.stream()          .map(msg -> new AiMessage(              msg.getRole().name().toLowerCase(),              msg.getContent()          ))          .collect(Collectors.toList());    }    // 현재 사용자 메시지 추가    aiMessages.add(new AiMessage("user", userMessage));    // 사용자 메시지 저장    messageService.saveUserMessage(userMessage, conversation);    // OpenAI 호출 (컨텍스트 포함)    String aiResponse = openAiService.getChatCompletion(aiMessages);    // AI 응답 메시지 저장    messageService.saveAssistantMessage(aiResponse, conversation);    log.info("채팅 응답 완료 - 대화 ID: {}", conversation.getConversationId());    return ChatResponse.of(aiResponse);  }  /**   * 채팅 스트리밍 (새 대화 또는 기존 대화 이어가기)   */  @Transactional  public SseEmitter chatStream(String userMessage, Long conversationId, Long userId) {    log.info("채팅 스트리밍 요청 - 사용자 ID: {}, 대화 ID: {}, 사용자 메시지: {}", userId, conversationId, userMessage);    SseEmitter emitter = new SseEmitter(60000L);  // 60초 타임아웃    Conversation conversation;    List<AiMessage> aiMessages = new ArrayList<>();    if (conversationId == null) {      User user = userRepository.findById(userId)          .orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다."));      // 새 대화 시작      log.info("새 대화 시작");      String title = userMessage.length() > 30          ? userMessage.substring(0, 30) + "..."          : userMessage;      conversation = Conversation.builder()          .title(title)          .user(user)          .build();      conversationRepository.save(conversation);    } else {      // 기존 대화 이어가기      log.info("기존 대화 이어가기 - 대화 ID: {}", conversationId);      conversation = conversationRepository          .findByConversationIdAndUserUserId(conversationId, userId)          .orElseThrow(() -> new ConversationAccessDeniedException(conversationId));      List<Message> recentMessages = messageRepository          .findTop10ByConversationConversationIdOrderByCreatedAtDesc(conversationId);      aiMessages = recentMessages.stream()          .map(msg -> new AiMessage(              msg.getRole().name().toLowerCase(),              msg.getContent()          ))          .collect(Collectors.toList());      log.info("컨텍스트 메시지 개수: {}", aiMessages.size());    }    // 현재 사용자 메시지 추가    aiMessages.add(new AiMessage("user", userMessage));    // 사용자 메시지 저장    messageService.saveUserMessage(userMessage, conversation);    // 비동기로 스트리밍 처리    Conversation finalConversation = conversation;    List<AiMessage> finalAiMessages = aiMessages;    new Thread(() -> {      try {        // OpenAI 스트리밍 호출        String fullResponse = openAiService.getChatCompletionStream(finalAiMessages, emitter);        // AI 응답 저장 (스트리밍 완료 후)        messageService.saveAssistantMessage(fullResponse, finalConversation);        log.info("채팅 스트리밍 완료 - 대화 ID: {}", finalConversation.getConversationId());      } catch (Exception e) {        log.error("스트리밍 처리 중 오류", e);      }    }).start();    return emitter;  }  /**   * 내 대화 목록 조회   */  public List<ConversationListResponse> getConversationList(Long userId) {    List<Conversation> conversations = conversationRepository        .findByUserUserIdOrderByCreatedAtDesc(userId);    return conversations.stream()        .map(ConversationListResponse::from)        .collect(Collectors.toList());  }  /**   * 대화 상세 조회 (메시지 포함)   */  public ConversationDetailResponse getConversationDetail(Long conversationId, Long userId) {    Conversation conversation = conversationRepository        .findByConversationIdAndUserUserId(conversationId, userId)        .orElseThrow(() -> new ConversationAccessDeniedException(conversationId));    List<MessageResponse> messages = messageService.getMessagesByConversationId(conversationId);    return new ConversationDetailResponse(        conversation.getConversationId(),        conversation.getTitle(),        conversation.getCreatedAt(),        conversation.getUpdatedAt(),        messages    );  }  /**   * 대화 삭제   */  @Transactional  public ConversationDeleteResponse deleteConversation(Long conversationId, Long userId) {    Conversation conversation = conversationRepository        .findByConversationIdAndUserUserId(conversationId, userId)        .orElseThrow(() -> new ConversationAccessDeniedException(conversationId));    conversationRepository.delete(conversation);    log.info("대화 삭제 완료 - 대화 ID: {}", conversationId);    return ConversationDeleteResponse.of(conversationId);  }  /**   * 대화 검색   */  public List<ConversationListResponse> searchConversations(String keyword, Long userId) {    List<Conversation> conversations = conversationRepository        .searchByTitleAndUserId(keyword, userId);    return conversations.stream()        .map(ConversationListResponse::from)        .collect(Collectors.toList());  }}